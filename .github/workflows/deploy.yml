name: Deploy App (post-apply)

on:
  workflow_run:
    workflows: ["Terraform Apply"]
    types: [completed]
  workflow_dispatch:

permissions:
  contents: read

jobs:
  deploy:
    if: ${{ github.event_name == 'workflow_dispatch' || github.event.workflow_run.conclusion == 'success' }}
    environment:
      name: production
    runs-on: ubuntu-latest
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.SPACES_ACCESS_KEY_ID }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.SPACES_SECRET_ACCESS_KEY }}
      
      TF_VAR_do_token: ${{ secrets.DO_TOKEN }}
      TF_VAR_ssh_key_id: ${{ secrets.TF_VAR_ssh_key_id }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      - name: Terraform Init (read outputs)
        working-directory: ./terraform
        run: |
          terraform init -input=false

      - name: Export droplet IP
        id: output
        working-directory: ./terraform
        run: |
          echo "droplet_ip=$(terraform output -raw droplet_ip)" >> $GITHUB_OUTPUT
          echo "site_fqdn=$(terraform output -raw site_fqdn)" >> $GITHUB_OUTPUT

      - name: Set up SSH agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.SSH_PRIVATE_KEY }}

      - name: Add droplet to known_hosts
        run: |
          DROPLET_IP="${{ steps.output.outputs.droplet_ip }}"
          mkdir -p ~/.ssh
          # Prefer avoiding host key strict checks in CI to prevent failures on droplet reprovisioning
          echo -e "Host $DROPLET_IP\n  StrictHostKeyChecking no\n  UserKnownHostsFile=/dev/null\n" >> ~/.ssh/config

      - name: Prepare remote directory
        run: |
          DROPLET_IP="${{ steps.output.outputs.droplet_ip }}"
          
          for i in {1..30}; do
            if ssh -o BatchMode=yes -o ConnectTimeout=5 root@"$DROPLET_IP" "echo ok" >/dev/null 2>&1; then
              echo "SSH is ready"; break; fi; echo "waiting ssh..."; sleep 5; done
          
          ssh root@"$DROPLET_IP" bash -lc '
            for i in {1..60}; do
              if [ -f /var/log/cloud-init-done.flag ]; then echo "cloud-init done"; break; fi; echo "waiting cloud-init..."; sleep 5;
            done
          '
          ssh root@"$DROPLET_IP" "mkdir -p /opt/hazelcast-poc"

      - name: Upload project to droplet (rsync)
        run: |
          DROPLET_IP="${{ steps.output.outputs.droplet_ip }}"
          rsync -az --delete -e "ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null" \
            --exclude='.git' \
            --exclude='.github' \
            --exclude='**/.git' \
            ./ root@"$DROPLET_IP":/opt/hazelcast-poc/

      - name: Create .env locally
        env:
          MARIADB_ROOT_PASSWORD: ${{ secrets.MARIADB_ROOT_PASSWORD }}
          MARIADB_DATABASE: ${{ secrets.MARIADB_DATABASE }}
          MARIADB_USER: ${{ secrets.MARIADB_USER }}
          MARIADB_PASSWORD: ${{ secrets.MARIADB_PASSWORD }}
        run: |
          {
            echo "MARIADB_ROOT_PASSWORD='${MARIADB_ROOT_PASSWORD}'"
            echo "MARIADB_DATABASE='${MARIADB_DATABASE}'"
            echo "MARIADB_USER='${MARIADB_USER}'"
            echo "MARIADB_PASSWORD='${MARIADB_PASSWORD}'"
          } > dist.env

      - name: Upload .env to droplet
        run: |
          DROPLET_IP="${{ steps.output.outputs.droplet_ip }}"
          scp -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null dist.env root@"$DROPLET_IP":/opt/hazelcast-poc/.env


      - name: Ensure swap on droplet (2G)
        run: |
          DROPLET_IP="${{ steps.output.outputs.droplet_ip }}"
          ssh root@"$DROPLET_IP" bash -lc '
            set -euo pipefail
            if ! swapon --show | grep -q "/swapfile"; then
              echo "Ensuring 2G swapfile present"
              if [ ! -f /swapfile ]; then
                fallocate -l 2G /swapfile 2>/dev/null || dd if=/dev/zero of=/swapfile bs=1M count=2048
                chmod 600 /swapfile
                mkswap /swapfile || true
              fi
              swapon /swapfile || true
              if ! grep -q "^/swapfile" /etc/fstab; then
                echo "/swapfile none swap sw 0 0" >> /etc/fstab
              fi
            fi
          '

      - name: Docker Compose Up (build on droplet)
        run: |
          DROPLET_IP="${{ steps.output.outputs.droplet_ip }}"
          ssh -o ServerAliveInterval=30 -o ServerAliveCountMax=10 -o TCPKeepAlive=yes root@"$DROPLET_IP" bash -lc '
            set -euo pipefail
            export DOCKER_BUILDKIT=1
            export COMPOSE_DOCKER_CLI_BUILD=1
            cd /opt/hazelcast-poc

            if ! command -v docker >/dev/null 2>&1; then
              echo "Installing docker (fallback)"
              export DEBIAN_FRONTEND=noninteractive
              apt-get update -y || true
              apt-get install -y --no-install-recommends docker.io docker-compose-plugin || true
            fi
            systemctl enable docker || true
            systemctl start docker || true
            
            for i in {1..30}; do
              if docker info >/dev/null 2>&1; then echo "Docker is ready"; break; fi; echo "waiting docker..."; sleep 2; done

            HOST="${{ steps.output.outputs.site_fqdn }}"
            if [ -f .env ]; then
              grep -q '^SERVER_NAME=' .env && sed -i "s/^SERVER_NAME=.*/SERVER_NAME=$HOST/" .env || echo "SERVER_NAME=$HOST" >> .env
              grep -q '^ENABLE_SSL=' .env && sed -i "s/^ENABLE_SSL=.*/ENABLE_SSL=true/" .env || echo "ENABLE_SSL=true" >> .env
              grep -q '^HTTPS_PORT=' .env && sed -i "s/^HTTPS_PORT=.*/HTTPS_PORT=443/" .env || echo "HTTPS_PORT=443" >> .env
              grep -q '^APP_PORT=' .env && sed -i "s/^APP_PORT=.*/APP_PORT=80/" .env || echo "APP_PORT=80" >> .env
            else
              printf "SERVER_NAME=%s\nENABLE_SSL=true\nHTTPS_PORT=443\nAPP_PORT=80\n" "$HOST" > .env
            fi

            docker compose down || true
            docker compose pull || true
            docker compose build
            docker compose up -d
            docker compose ps
          '

      - name: Health check (web)
        run: |
          HOST="${{ steps.output.outputs.site_fqdn }}"
          echo "Waiting for DNS to resolve $HOST ..."
          for i in {1..30}; do
            if getent hosts "$HOST" >/dev/null 2>&1; then
              echo "$HOST resolved"; break; fi; sleep 5; done
          echo "Checking http://$HOST ..."
          for i in {1..30}; do
            code=$(curl -sS -o /dev/null -L -w "%{http_code}" "http://$HOST") || code=000
            echo "HTTP status: $code"
            case "$code" in
              2*|3*) echo "App is healthy"; exit 0;;
            esac
            sleep 5
          done
          echo "Health check failed"; exit 1

      - name: Wait for API container healthy (on droplet)
        run: |
          DROPLET_IP="${{ steps.output.outputs.droplet_ip }}"
          ssh root@"$DROPLET_IP" bash -lc '
            set -euo pipefail
            for i in {1..60}; do
              status=$(docker inspect -f {{.State.Health.Status}} hazelcast-poc-api 2>/dev/null || echo "unknown")
              echo "API container health: $status"
              if [ "$status" = "healthy" ]; then exit 0; fi
              sleep 5
            done
            echo "API container did not become healthy in time"; exit 1
          '

      - name: Health check (api via Nginx)
        run: |
          HOST="${{ steps.output.outputs.site_fqdn }}"
          echo "Checking API through Nginx at http://$HOST/api/actuator/health ..."
          for i in {1..60}; do
            code=$(curl -sS -o /dev/null -L -k -w "%{http_code}" "http://$HOST/api/actuator/health" || echo 000)
            echo "HTTP status (api): $code"
            body=$(curl -sS -L -k "http://$HOST/api/actuator/health" || true)
            if echo "$body" | grep -q '"status"\s*:\s*"UP"'; then
              echo "API is healthy"; exit 0;
            fi
            sleep 5
          done
          echo "API health check failed"; exit 1

      - name: Issue/Renew TLS certificate (Let\'s Encrypt)
        env:
          CERTBOT_EMAIL: ${{ secrets.CERTBOT_EMAIL }}
        run: |
          HOST="${{ steps.output.outputs.site_fqdn }}"
          DROPLET_IP="${{ steps.output.outputs.droplet_ip }}"
          ssh root@"$DROPLET_IP" bash -lc '
            set -euo pipefail
            cd /opt/hazelcast-poc
            
            docker compose run --rm certbot certonly --webroot -w /var/www/certbot \
              -d '"$HOST"' --email '"${CERTBOT_EMAIL}"' --agree-tos --no-eff-email || true
            
            docker compose restart web
          '

      - name: Verify TLS certs on droplet
        id: tlscheck
        run: |
          HOST="${{ steps.output.outputs.site_fqdn }}"
          DROPLET_IP="${{ steps.output.outputs.droplet_ip }}"
          if ssh root@"$DROPLET_IP" "[ -f /etc/letsencrypt/live/$HOST/fullchain.pem ] && [ -f /etc/letsencrypt/live/$HOST/privkey.pem ]"; then
            echo "has_certs=true" >> $GITHUB_OUTPUT
            echo "TLS certs present on droplet"
          else
            echo "has_certs=false" >> $GITHUB_OUTPUT
            echo "TLS certs not found on droplet; skipping HTTPS health check"
          fi

      - name: Health check (HTTPS)
        if: steps.tlscheck.outputs.has_certs == 'true'
        run: |
          HOST="${{ steps.output.outputs.site_fqdn }}"
          echo "Checking https://$HOST ..."
          for i in {1..30}; do
            if curl -fsS "https://$HOST" -k >/dev/null; then
              echo "HTTPS is healthy"; exit 0;
            fi
            sleep 5
          done
          echo "HTTPS health check failed"; exit 1

      - name: Cleanup Docker cache (optional)
        env:
          PRUNE_AFTER_DEPLOY: ${{ vars.PRUNE_AFTER_DEPLOY }}
        run: |
          DROPLET_IP="${{ steps.output.outputs.droplet_ip }}"
          ssh root@"$DROPLET_IP" bash -lc '
            set -euo pipefail
            if [ "${PRUNE_AFTER_DEPLOY:-true}" = "true" ]; then
              echo "Pruning dangling images and build cache..."
              docker image prune -af || true
              docker builder prune -af || true
              docker system df || true
            else
              echo "Skipping prune (PRUNE_AFTER_DEPLOY=false)"
            fi
          '
